# -*- coding: utf-8 -*-
"""Sumary_task_Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WP2-ESBnYIOIcfAg2Fr1OB_a5kI8Vu4_
"""

# === Для подключения в облачной БД ===
!pip install python-dotenv
from dotenv import load_dotenv
# === Явки-пароли от БД ===
from google.colab import files
uploaded = files.upload()

# === Импорт модулей ====
import psycopg2, requests, json, logging, os, ast
from datetime import datetime, timedelta
from pathlib import Path
from psycopg2.extras import execute_values
import pandas as pd

# === Логирование ===

logs_dir = Path("logs")#создается путь к папке logs для хранения файлов .log
logs_dir.mkdir(exist_ok=True)#создается папка logs (если она уже есть, то избегать ошибки)
now = datetime.now() #текущее время

#удаление логов старше трех дней
for log_file in logs_dir.glob("*.log"):
    if (now - datetime.fromtimestamp(log_file.stat().st_mtime)).days > 3:
        log_file.unlink()

# имя текущего лог-файла по текущей дате
log_filename = logs_dir / f"{now.strftime('%Y-%m-%d')}.log"

#очистить старые хендлеры
for handler in logging.root.handlers[:]:
    logging.root.removeHandler(handler)

#настройка логирования
logging.basicConfig(
    filename=log_filename,
    level=logging.INFO,
    format='%(asctime)s %(name)s %(levelname)s: %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logging.info(f"Начало логирования {now}")


# === API ===

def fetch_data(start, end): #функция получения данных из API
    api_url = "https://b2b.itresume.ru/api/statistics" #URL-адрес
    #дополнительные параметры
    data = {
        "client": "Skillfactory",
        "client_key": "M2MGWS",
        "start": start,
        "end": end
    }
    try:
        logging.info("Начало скачивания данных с API.")
        response = requests.get(api_url, params=data)#непосредственно запрос API
        response.raise_for_status()#если HTTP-статус ответа — не 200, то except.
        logging.info("Скачивание завершено успешно.")
        return response.json()

    except requests.exceptions.HTTPError as e:
        logging.error(f"Ошибка HTTP: {e} - Статус: {response.status_code}")
        return []

    except requests.RequestException as e:
        logging.error(f"Ошибка при обращении к API: {e}")
        return []


# === Обработка данных ===

def parse_passback_params(raw): #функция для преобрзования строки passback_params в словарь
    try:
        return ast.literal_eval(raw) #парсинг строки посредством  обработки деревьев абстрактных синтаксических грамматик
        #json.loads(raw.replace("'", "\"")) - без дерева синтаксических грамматик тоже можно
    except Exception as e:
        logging.warning(f"Не удалось разобрать passback_params: {raw} | Ошибка: {e}")
        return {}#в случае ошибки - пустой словарь


def process_data(response): #функция для обработки данных, полученных из fetch_data(), т.е. из API
    processed = []
    for r in response:
        passback = parse_passback_params(r.get("passback_params", "{}"))
        try:
            record = {
                "user_id": r["lti_user_id"],#строковый id пользователя
                "oauth_consumer_key": passback.get("oauth_consumer_key", ""), #уникальный токен клиента
                "lis_result_sourcedid": passback.get("lis_result_sourcedid", ""), # ссылка на блок, в котором находится задача в ЛМС
                "lis_outcome_service_url": passback.get("lis_outcome_service_url", ""),# URL адрес в ЛМС, куда мы шлем оценку
                "is_correct": None if r['attempt_type'] == "run" else r['is_correct'], # была ли попытка верной (null, если это run)
                "attempt_type": r["attempt_type"], # ран(запуск без проверки) или сабмит(на проверку)
                "created_at": datetime.strptime(r['created_at'], '%Y-%m-%d %H:%M:%S.%f') # дата и время попытки
            }

            if not record["user_id"] or not record["created_at"]: #если строковый id пользователя или дата и время попытки отсутствуют - запись в лог и никаких гвоздей
                raise ValueError("Пропущены обязательные поля")

            processed.append(record)
        except Exception as e:
            logging.warning(f"Ошибка при обработке записи: {e} | Запись: {r}")
    return processed #список словарей с данными, готовыим для загрузки в БД


# === Загрузка в облачную БД ===

def insert_to_db(processed): #функция для загрузки в БД

    if not processed:#если список пустой - запись в лог и всё
        logging.info("Нет данных для загрузки в базу.")
        return

    try:
        #явки-пароли
        load_dotenv(".env")
        HOST = os.getenv("HOST")
        PORT = os.getenv("PORT")
        DATABASE = os.getenv("DATABASE")
        USER = os.getenv("USER")
        PASSWORD = os.getenv("PASSWORD")

        conn = psycopg2.connect( # создается подключение в БД
            dbname=DATABASE,
            user=USER,
            password=PASSWORD,
            host=HOST,
            port=PORT
        )

        cursor = conn.cursor() # создается курсор

        logging.info("Начало загрузки данных в базу.")

        #SQL-запрос для вставки в БД
        insert_query = """
            INSERT INTO pars_db (
                user_id, oauth_consumer_key, lis_result_sourcedid,
                lis_outcome_service_url, is_correct, attempt_type, created_at
            ) VALUES %s
        """
        #подготовка данных для вставки
        data_tuples = [
            (
                r["user_id"],
                r["oauth_consumer_key"],
                r["lis_result_sourcedid"],
                r["lis_outcome_service_url"],
                r["is_correct"],
                r["attempt_type"],
                r["created_at"]
            ) for r in processed
        ]

        execute_values(cursor, insert_query, data_tuples)#для вставки больших объемов данных
        conn.commit()#подтверждение транзакциии
        logging.info("Загрузка в базу завершена успешно.")
        cursor.close()#закрыть курсор
        conn.close()#закрыть соединение

    except Exception as e:
        logging.error(f"Ошибка при загрузке в базу данных: {e}")


# === Запуск ===

end_time = datetime.utcnow() #получить текущее время
start_time = end_time - timedelta(days=1) #начало периода за сутки до текущего времени

try:
    #raw хранит данные, выкаченные функцией fetch_data()
    raw = fetch_data(
          start=start_time.strftime("%Y-%m-%d %H:%M:%S.%f"),
          end=end_time.strftime("%Y-%m-%d %H:%M:%S.%f")
                    )
    #data хранит проверенные и обработанные данные
    data = process_data(raw)

    #заносим данные в БД
    insert_to_db(data)
except Exception as e:
    logging.exception("Произошла ошибка")

finally:
    with open(log_filename, "r", encoding='utf-8') as f:
        print(f.read())

# === Подключаемся в БД, собираем данные в DF ===
# функция подключения к БД и DF
def get_df(start_time, end_time):
    try:
        #явки-пароли
        load_dotenv(".env")
        HOST = os.getenv("HOST")
        PORT = os.getenv("PORT")
        DATABASE = os.getenv("DATABASE")
        USER = os.getenv("USER")
        PASSWORD = os.getenv("PASSWORD")

        conn = psycopg2.connect( # создается подключение в БД
            dbname=DATABASE,
            user=USER,
            password=PASSWORD,
            host=HOST,
            port=PORT
        )

        cursor = conn.cursor() # создается курсор
        cursor.execute('SELECT * FROM pars_db WHERE (created_at >= %s and created_at <= %s)', (start_time, end_time,))
        res = cursor.fetchall()
        df = pd.DataFrame(res, columns=['user_id', 'oauth_consumer_key', 'lis_result_sourcedid', 'lis_outcome_service_url', 'is_correct', 'attempt_type', 'created_at'])

        #подсчет параметров
        total_rows = len(df) #сколько попыток (run и submit) всего было совершено за день
        submit_count = len(df[df['attempt_type'] == 'submit'])#сколько попыток (submit) было совершено за день
        is_correct_count = len(df[df['is_correct'] == '1'])#сколько успешных попыток было из всех совершенных за день
        user_id_count = len(df['user_id'].unique())#количество уникальных юзеров за день

        #для вычисления среднего числа попыток
        def attempts_until_correct(group):
            try:
                idx = group['is_correct'].idxmax()  # первая правильная попытка
                return group.loc[:idx].shape[0]
            except:
                return None  # если правильного нет
        df_sorted = df.sort_values(['user_id', 'created_at'])#сортируем фрейм по пользователям и времени
        attempts_to_success = df_sorted.groupby('user_id').apply(attempts_until_correct).dropna()
        avg_attempts_to_success = round(attempts_to_success.mean(), 2) if not attempts_to_success.empty else None

        # кол-во пользователей с 0 правильных
        users_with_no_correct = df.groupby('user_id')['is_correct'].sum()
        users_with_zero_correct = (users_with_no_correct == 0).sum()

        cursor.close()#закрыть курсор
        conn.close()#закрыть соединение
    except Exception as e:
        print("Не удалось подключиться к БД")
    return total_rows, submit_count, is_correct_count, round(is_correct_count/submit_count, 2), user_id_count, round(total_rows/user_id_count, 2),avg_attempts_to_success, users_with_zero_correct

# === Таблица в GoogleSheets вариант 1 для GoogleColab===

#доступ к аккаунту
from google.colab import auth
auth.authenticate_user()

#импорт модулей
import gspread
from google.auth import default

#Подключение к Google Sheets
creds, _ = default()
gc = gspread.authorize(creds)

#
import pandas as pd
from gspread_dataframe import set_with_dataframe

# Сбор данных из БД
today = start_time.strftime('%Y-%m-%d')
df = pd.DataFrame({
    'Дата': today,
    'Показатель': ['Активности', 'Проверки', 'Верные ответы', 'Доля верных ответов, %', 'Активных пользователей', 'Среднее число попыток на пользователя', 'Среднее число попыток до правильного ответа', 'Кол-во пользователей с 0 правильных'],
    'Кол-во': get_df(start_time, end_time),
    'Примечание':['Всего за день попыток решить и проверить задачи','Всего за день попыток проверить задачи','Успешные проверки задачи','Доля успешных проверок задач в общем числе проверок за день', 'Всего уникальных пользователей за день','Насколько активно учились (в среднем по каждому)','Насколько быстро люди находят верный ответ','Кто совсем не справился']
    })




# Подключаемся к Google Sheet
sheet_id = "14NOMnloo2KETuRHkjm0Vj-JtEg0i-Ve0yAHgVur2NjI"  # ID созданной в ручную таблицы
sh = gc.open_by_key(sheet_id)

# Выбираем лист (по умолчанию - первый)
worksheet = sh.sheet1

# Загружаем данные в таблицу
set_with_dataframe(worksheet, df)

# Откроем таблицу в новой вкладке/через кнопку "Открыть Google Таблицу"
#import webbrowser
#print(f"🔗 Вот ссылка на таблицу:\nhttps://docs.google.com/spreadsheets/d/{sheet_id}/edit")

from IPython.display import HTML
sheet_url = f"https://docs.google.com/spreadsheets/d/{sheet_id}/edit"
HTML(f'<a href="{sheet_url}" target="_blank"><button>Открыть Google Таблицу</button></a>')

# === Задание с двумя звездочками: оповещения на почту ===

#импорт модулей
import smtplib
import ssl
from email.message import EmailMessage

#фнкция отправки письма
def send_email_notification(subject, body):
    try:
      # Настройки
        smtp_server = "smtp.mail.ru"
        port = 465  # SSL порт
        sender_email = "therestwetest@mail.ru"
        receiver_email = "marfa_ii@mail.ru"
        password = "EsfsENn017ramemS7RW8"  # Специальный пароль приложения
      # Создаем сообщение
        msg = EmailMessage()
        msg.set_content(body)
        msg["Subject"] = subject
        msg["From"] = sender_email
        msg["To"] = receiver_email

      # HTML-версия с таблицей
        html_content = f"""
        <html>
            <body>
                <p>Добрый день!<br><br>
                Отчет за <b>{today}</b> успешно сформирован и загружен в Google Таблицу.<br>
                Ниже — краткое содержание отчета:</p>
                {html_table}
                <p>Хорошего дня!<br> </p>
            </body>
        </html>
        """
        msg.add_alternative(html_content, subtype="html")



      # Защищённое соединение
        context = ssl.create_default_context()
        with smtplib.SMTP_SSL(smtp_server, port, context=context) as server:
            server.login(sender_email, password)
            server.send_message(msg)

        logging.info("Письмо успешно отправлено.")
    except Exception as e:
        logging.error(f"Ошибка при отправке email: {e}")


# === Email уведомление после отправки в Google Sheets ===
# Сконвертируем df в HTML-таблицу с красивыми границами
html_table = df.to_html(index=False, border=1, justify="center")

subject = f"Отчет за {today} успешно сформирован"
send_email_notification(subject, html_table)